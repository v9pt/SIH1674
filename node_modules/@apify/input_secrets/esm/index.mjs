import __ow_import from 'ow';
const __injectedOw = __ow_import.default || __ow_import;
var __defProp = Object.defineProperty;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });

// src/input_secrets.ts
import { KeyObject } from "crypto";
import { privateDecrypt, publicEncrypt } from "@apify/utilities";
import _testOw from "ow";
var ow = typeof __injectedOw === "undefined" ? _testOw : __injectedOw || _testOw;
var BASE64_REGEXP = /[-A-Za-z0-9+/]*={0,3}/;
var ENCRYPTED_INPUT_VALUE_PREFIX = "ENCRYPTED_VALUE";
var ENCRYPTED_INPUT_VALUE_REGEXP = new RegExp(`^${ENCRYPTED_INPUT_VALUE_PREFIX}:(${BASE64_REGEXP.source}):(${BASE64_REGEXP.source})$`);
function getInputSchemaSecretFieldKeys(inputSchema) {
  return Object.keys(inputSchema.properties).filter((key) => !!inputSchema.properties[key].isSecret);
}
__name(getInputSchemaSecretFieldKeys, "getInputSchemaSecretFieldKeys");
function encryptInputSecretValue({ value, publicKey }) {
  ow(value, ow.string);
  ow(publicKey, ow.object.instanceOf(KeyObject));
  const { encryptedValue, encryptedPassword } = publicEncrypt({ value, publicKey });
  return `${ENCRYPTED_INPUT_VALUE_PREFIX}:${encryptedPassword}:${encryptedValue}`;
}
__name(encryptInputSecretValue, "encryptInputSecretValue");
function encryptInputSecrets({ input, inputSchema, publicKey }) {
  ow(input, ow.object);
  ow(inputSchema, ow.object);
  ow(publicKey, ow.object.instanceOf(KeyObject));
  const secretsInInputKeys = getInputSchemaSecretFieldKeys(inputSchema);
  if (secretsInInputKeys.length === 0) return input;
  const encryptedInput = {};
  for (const key of secretsInInputKeys) {
    const value = input[key];
    if (value && ow.isValid(value, ow.string) && !ENCRYPTED_INPUT_VALUE_REGEXP.test(value)) {
      encryptedInput[key] = encryptInputSecretValue({ value: input[key], publicKey });
    }
  }
  return { ...input, ...encryptedInput };
}
__name(encryptInputSecrets, "encryptInputSecrets");
function decryptInputSecrets({ input, privateKey }) {
  ow(input, ow.object);
  ow(privateKey, ow.object.instanceOf(KeyObject));
  const decryptedInput = {};
  for (const [key, value] of Object.entries(input)) {
    if (ow.isValid(value, ow.string) && ENCRYPTED_INPUT_VALUE_REGEXP.test(value)) {
      const match = value.match(ENCRYPTED_INPUT_VALUE_REGEXP);
      if (!match) continue;
      const [, encryptedPassword, encryptedValue] = match;
      try {
        decryptedInput[key] = privateDecrypt({ privateKey, encryptedPassword, encryptedValue });
      } catch (err) {
        throw new Error(`The input field "${key}" could not be decrypted. Try updating the field's value in the input editor. Decryption error: ${err}`);
      }
    }
  }
  return { ...input, ...decryptedInput };
}
__name(decryptInputSecrets, "decryptInputSecrets");
export {
  decryptInputSecrets,
  encryptInputSecretValue,
  encryptInputSecrets,
  getInputSchemaSecretFieldKeys
};
//# sourceMappingURL=index.mjs.map