{"version":3,"sources":["../../src/index.ts","../../src/input_secrets.ts"],"sourcesContent":["export * from './input_secrets';\n","import { KeyObject } from 'crypto';\n\nimport { privateDecrypt, publicEncrypt } from '@apify/utilities';\nimport _testOw, { type Ow } from 'ow';\n\n// eslint-disable-next-line no-underscore-dangle\ndeclare const __injectedOw: Ow;\n\nconst ow: Ow = typeof __injectedOw === 'undefined' ? _testOw : __injectedOw || _testOw;\n\nconst BASE64_REGEXP = /[-A-Za-z0-9+/]*={0,3}/;\nconst ENCRYPTED_INPUT_VALUE_PREFIX = 'ENCRYPTED_VALUE';\nconst ENCRYPTED_INPUT_VALUE_REGEXP = new RegExp(`^${ENCRYPTED_INPUT_VALUE_PREFIX}:(${BASE64_REGEXP.source}):(${BASE64_REGEXP.source})$`);\n\n/**\n * Get keys of secret fields from input schema\n */\nexport function getInputSchemaSecretFieldKeys(inputSchema: any): string[] {\n    return Object.keys(inputSchema.properties)\n        .filter((key) => !!inputSchema.properties[key].isSecret);\n}\n\n/**\n * Encrypts input secret value\n */\nexport function encryptInputSecretValue({ value, publicKey }: { value: string, publicKey: KeyObject }): string {\n    ow(value, ow.string);\n    ow(publicKey, ow.object.instanceOf(KeyObject));\n\n    const { encryptedValue, encryptedPassword } = publicEncrypt({ value, publicKey });\n    return `${ENCRYPTED_INPUT_VALUE_PREFIX}:${encryptedPassword}:${encryptedValue}`;\n}\n\n/**\n * Encrypts actor input secrets\n */\nexport function encryptInputSecrets<T extends Record<string, any>>(\n    { input, inputSchema, publicKey }: { input: T, inputSchema: object, publicKey: KeyObject },\n): T {\n    ow(input, ow.object);\n    ow(inputSchema, ow.object);\n    ow(publicKey, ow.object.instanceOf(KeyObject));\n\n    const secretsInInputKeys = getInputSchemaSecretFieldKeys(inputSchema);\n    if (secretsInInputKeys.length === 0) return input;\n\n    const encryptedInput = {} as Record<string, any>;\n    for (const key of secretsInInputKeys) {\n        const value = input[key];\n        // NOTE: Skips already encrypted values. It can happens in case client already encrypted values, before\n        // sending them using API. Or input was takes from task, run console or scheduler, where input is stored encrypted.\n        if (value && ow.isValid(value, ow.string) && !ENCRYPTED_INPUT_VALUE_REGEXP.test(value)) {\n            encryptedInput[key] = encryptInputSecretValue({ value: input[key], publicKey });\n        }\n    }\n\n    return { ...input, ...encryptedInput };\n}\n\n/**\n * Decrypts actor input secrets\n * @param {Object} input\n * @param {KeyObject} privateKey\n * @returns Object\n */\nexport function decryptInputSecrets<T>(\n    { input, privateKey }: { input: T, privateKey: KeyObject },\n): T {\n    ow(input, ow.object);\n    ow(privateKey, ow.object.instanceOf(KeyObject));\n\n    const decryptedInput = {} as Record<string, any>;\n    for (const [key, value] of Object.entries(input)) {\n        if (ow.isValid(value, ow.string) && ENCRYPTED_INPUT_VALUE_REGEXP.test(value)) {\n            const match = value.match(ENCRYPTED_INPUT_VALUE_REGEXP);\n            if (!match) continue;\n            const [, encryptedPassword, encryptedValue] = match;\n            try {\n                decryptedInput[key] = privateDecrypt({ privateKey, encryptedPassword, encryptedValue });\n            } catch (err) {\n                throw new Error(`The input field \"${key}\" could not be decrypted. Try updating the field's value in the input editor. `\n                + `Decryption error: ${err}`);\n            }\n        }\n    }\n\n    return { ...input, ...decryptedInput };\n}\n"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;ACAA,oBAA0B;AAE1B,uBAA8C;AAC9C,gBAAiC;AAKjC,IAAM,KAAS,OAAO,iBAAiB,cAAc,UAAAA,UAAU,gBAAgB,UAAAA;AAE/E,IAAM,gBAAgB;AACtB,IAAM,+BAA+B;AACrC,IAAM,+BAA+B,IAAI,OAAO,IAAI,4BAA4B,KAAK,cAAc,MAAM,MAAM,cAAc,MAAM,IAAI;AAKhI,SAAS,8BAA8B,aAA4B;AACtE,SAAO,OAAO,KAAK,YAAY,UAAU,EACpC,OAAO,CAAC,QAAQ,CAAC,CAAC,YAAY,WAAW,GAAG,EAAE,QAAQ;AAC/D;AAHgB;AAQT,SAAS,wBAAwB,EAAE,OAAO,UAAU,GAAoD;AAC3G,KAAG,OAAO,GAAG,MAAM;AACnB,KAAG,WAAW,GAAG,OAAO,WAAW,uBAAS,CAAC;AAE7C,QAAM,EAAE,gBAAgB,kBAAkB,QAAI,gCAAc,EAAE,OAAO,UAAU,CAAC;AAChF,SAAO,GAAG,4BAA4B,IAAI,iBAAiB,IAAI,cAAc;AACjF;AANgB;AAWT,SAAS,oBACZ,EAAE,OAAO,aAAa,UAAU,GAC/B;AACD,KAAG,OAAO,GAAG,MAAM;AACnB,KAAG,aAAa,GAAG,MAAM;AACzB,KAAG,WAAW,GAAG,OAAO,WAAW,uBAAS,CAAC;AAE7C,QAAM,qBAAqB,8BAA8B,WAAW;AACpE,MAAI,mBAAmB,WAAW,EAAG,QAAO;AAE5C,QAAM,iBAAiB,CAAC;AACxB,aAAW,OAAO,oBAAoB;AAClC,UAAM,QAAQ,MAAM,GAAG;AAGvB,QAAI,SAAS,GAAG,QAAQ,OAAO,GAAG,MAAM,KAAK,CAAC,6BAA6B,KAAK,KAAK,GAAG;AACpF,qBAAe,GAAG,IAAI,wBAAwB,EAAE,OAAO,MAAM,GAAG,GAAG,UAAU,CAAC;AAAA,IAClF;AAAA,EACJ;AAEA,SAAO,EAAE,GAAG,OAAO,GAAG,eAAe;AACzC;AArBgB;AA6BT,SAAS,oBACZ,EAAE,OAAO,WAAW,GACnB;AACD,KAAG,OAAO,GAAG,MAAM;AACnB,KAAG,YAAY,GAAG,OAAO,WAAW,uBAAS,CAAC;AAE9C,QAAM,iBAAiB,CAAC;AACxB,aAAW,CAAC,KAAK,KAAK,KAAK,OAAO,QAAQ,KAAK,GAAG;AAC9C,QAAI,GAAG,QAAQ,OAAO,GAAG,MAAM,KAAK,6BAA6B,KAAK,KAAK,GAAG;AAC1E,YAAM,QAAQ,MAAM,MAAM,4BAA4B;AACtD,UAAI,CAAC,MAAO;AACZ,YAAM,CAAC,EAAE,mBAAmB,cAAc,IAAI;AAC9C,UAAI;AACA,uBAAe,GAAG,QAAI,iCAAe,EAAE,YAAY,mBAAmB,eAAe,CAAC;AAAA,MAC1F,SAAS,KAAK;AACV,cAAM,IAAI,MAAM,oBAAoB,GAAG,mGAChB,GAAG,EAAE;AAAA,MAChC;AAAA,IACJ;AAAA,EACJ;AAEA,SAAO,EAAE,GAAG,OAAO,GAAG,eAAe;AACzC;AAtBgB;","names":["_testOw"]}